#include "kgmGameScene.h"
#include "kgmEffect.h"
#include "kgmDoor.h"
#include "kgmIGame.h"

#include "../kgmMain/kgmIResources.h"
#include "../kgmMain/kgmEnvironment.h"
#include "../kgmMain/kgmOGL.h"



kgmIGraphics*    gc = 0;

kgmTexture* texBump = 0;
kgmTexture* texEnv = 0;

void*  fbo_depthmapcamera;			//depth map in camera space
void*  fbo_lightmapcamera;			//light map in camera space
void*  fbo_colormapcamera;			//color map in camera space
void*  fbo_normalmapcamera;			//color map in camera space
void*  fbo_depthmaplight;			//shadow map in light space

void*  m_txOne;				//default white texture map 
void*  m_txZero;				//default black texture map 


mtx4		mtxLightProj;

bool		bUseMaterial = true;
bool		bUseTexture = true;
bool		bUseShader = true;

kgmTexture* m_txWater = 0;

//kgmFog		m_fog;
kgmShader*	m_shSkin = 0;
kgmShader*	m_shMesh = 0;
kgmShader*	m_shPoly = 0;
kgmShader*	m_shNormal = 0;
kgmShader*	m_shLightmap = 0;
kgmShader*  m_shader[16] = {0};

const uint  m_mapdim = 512;
const float m_lfov = DEGTORAD(190.0);//default 120

kgmGameScene::kgmGameScene(){
 m_light.position = vec3(100, 100, 1000);
 m_light.ambient = vec4(.7, .7, .7, 1.);
 m_light.diffuse = vec4(.5, .5, .5, 1.);
 m_light.specular = vec4(.4, .4, .4, 1.);
 m_light.range = 10000;
 m_light.intensity = 100;

 m_shadows = true;
 m_alight = &m_light;

 m_buffer = 0;
 m_pvertices = 0;
 m_pfaces = 0;
 m_vertices = 0;
 m_faces = 0;

 m_map = 0;
}

kgmGameScene::~kgmGameScene(){
}

void kgmGameScene::clear(){
 int i = 0;
 if(!gc)
  return;

 gc->gcSetTexture(0, 0);
 gc->gcSetTexture(1, 0);
 gc->gcSetTexture(2, 0);
 //gc->gcSetMaterial(0);
 gc->gcSetShader(0);

 if(m_buffer)		 
  gc->gcFreeVertexBuffer(m_buffer);
 m_pvertices.clear();
 m_pfaces.clear();
 m_buffer    = 0;
 m_pfaces  = 0;
 m_pvertices = 0;
 m_vertices  = 0;
 m_faces   = 0;
 m_chunks.clear();


 gc->gcFreeTexture(fbo_depthmapcamera);
 gc->gcFreeTexture(fbo_lightmapcamera);
 gc->gcFreeTexture(fbo_colormapcamera);
 gc->gcFreeTexture(fbo_normalmapcamera);
 gc->gcFreeTexture(fbo_depthmaplight);

 gc->gcFreeTexture(m_txOne);
 gc->gcFreeTexture(m_txZero);

 m_alight = 0;
 m_ashader = 0;
 m_atexture = 0;
 m_amaterial = 0;
 
 m_octtree.clear();
 m_map = 0;
}

// COMPILE AND BUILD SCENE
bool kgmGameScene::build(kgmGameMap* map){
 uint i = 0;
 m_alight = 0;
 m_ashader = 0;
 m_atexture = 0;
 m_amaterial = 0;

 m_render_polygons = m_render_meshes = m_render_actors = 
 m_shaders = m_enmaterials = true;

 gc	       = kgmIGame::getGame()->getGraphics();
 m_shLight     = kgmIGame::getGame()->getResources()->getShader("light");
 m_shBump      = kgmIGame::getGame()->getResources()->getShader("bump");
 m_shWater     = kgmIGame::getGame()->getResources()->getShader("water");
 m_shLightmap  = kgmIGame::getGame()->getResources()->getShader("lightmap");
 m_shShadowmap = kgmIGame::getGame()->getResources()->getShader("shadowmap");
 m_shMesh      = kgmIGame::getGame()->getResources()->getShader("mesh");
 m_shPoly      = kgmIGame::getGame()->getResources()->getShader("polygon");
 m_shSkin      = kgmIGame::getGame()->getResources()->getShader("skin");
 m_shNormal    = kgmIGame::getGame()->getResources()->getShader("normals");
 m_shLightmap  = kgmIGame::getGame()->getResources()->getShader("lightmap");

 m_shader[0]  = kgmIGame::getGame()->getResources()->getShader("shader_01");
 m_shader[1]  = kgmIGame::getGame()->getResources()->getShader("shader_02");
 m_shader[2]  = kgmIGame::getGame()->getResources()->getShader("shader_03");

// texBump	= kgmApp::getResource()->getTexture("normal.bmp");
 texBump	= kgmIGame::getGame()->getResources()->getTexture("oceanBump.tga");
 texEnv		= kgmIGame::getGame()->getResources()->getTexture("brick_a.bmp");

 //m_fog.m_color = vec4(.9, .9, .9, 1);
 //m_fog.m_density = .5;
 //m_fog.m_end = 50;
 //m_fog.m_start = 1;

 m_space = box3(vec3(-1, -1, -1), vec3(1, 1, 1));

 m_map = map;
 //build scene mesh
 if(m_map && m_map->m_meshs.length() > 0){
  uint vcount = 0, fcount = 0;
  for(int i = 0; i < m_map->m_meshs.length(); i++){
   vcount += m_map->m_meshs[i]->m_vertices.length();
   fcount += m_map->m_meshs[i]->m_faces.length();
  }

  //alloc memory for geometry 
  if((vcount > 0) && (fcount > 0)){
   m_vertices.realloc(vcount);
   m_faces.realloc(fcount);
   m_imaps.realloc(fcount);
  } 

  //fill geometry data
  uint ivs = 0, ifs = 0;
  Vertex* v = m_vertices.data();
  Face*   f = m_faces.data();
  ushort* fm = m_imaps.data();
  for(int i = 0; i < m_map->m_meshs.length(); i++){
   kgmMesh* m = m_map->m_meshs[i];
   for(uint iv = 0; iv < m->m_vertices.length(); iv++){
   }
   for(uint it = 0; it < m->m_faces.length(); it++){
   }
   vcount += m_map->m_meshs[i]->m_vertices.length();
   fcount += m_map->m_meshs[i]->m_faces.length();
  }
  
 }

 //octtree
 m_octtree.build(m_space, 4);
 //render target
// fbo_lightmapcamera  = gc->gcGenRenderTarget(m_mapdim, m_mapdim, 0x01);
// fbo_colormapcamera  = gc->gcGenRenderTarget(m_mapdim, m_mapdim, 0x01);
// fbo_normalmapcamera = gc->gcGenRenderTarget(m_mapdim, m_mapdim, 0x01);
// fbo_depthmapcamera  = gc->gcGenRenderTarget(m_mapdim, m_mapdim, 0x02);
// fbo_depthmaplight   = gc->gcGenRenderTarget(m_mapdim, m_mapdim, 0x02);

 //generic default white texture
 char txd[16] = {0xff};
 memset(txd, 0xffffffff, sizeof(txd));
 m_txOne = gc->gcGenTexture(txd, 2, 2, 32, 0);
 memset(txd, 0x00, sizeof(txd));
 m_txZero = gc->gcGenTexture(txd, 2, 2, 32, 0);

 return true;
}

// RENDERING SCENE
uint m_rstage = 0;
char s_buf[128];
uint frames, tick, f; 

void kgmGameScene::render(){
 static uint current_render = 0;
 static uint current_frame = 0;
 static int  k = 0;
 static uint rstep = 0;
 kgmCamera camera;
 vec3  pos, dir, up;
 mtx4  m,   mvw, mpr;
 lRect rc;

 vec3      v;
 vec4      light;

 kgmList<kgmLight*>		lights;
 kgmList<kgmActor*>		actors;
 kgmList<kgmEffect*>	effects;
 kgmList<IChunk*>		chunks;

 int  i;
 bool passing = true;
 rstep = 1;
 m_lock++;

 //rc = kgmGameApp::getWindow()->getRect();

//Collects Lights in camera space
  lights.add(&m_light);
  for(i = 0; i < m_lights.size(); i++){
   sphere s(m_lights[i]->position, m_lights[i]->range);
   if(m_acamera.isSphereCross(s.center, s.radius))
    lights.add(m_lights[i]);
  }

//Collect Actors in camera space
  for(i = 0; i < m_actors.size(); i++){
   sphere s(m_actors[i]->m_position, 10.0f);
   if(m_acamera.isSphereCross(s.center, s.radius))
    actors.add(m_actors[i]);
  }

//Collect Chunks in camera space
  for(i = 0; i < m_chunks.size(); i++){
    chunks.add(&m_chunks[i]);
  }

  m_acamera = m_camera;
/*Build DepthMap in camera space
  pOGLDev->gcSetViewport(0, 0, m_mapdim, m_mapdim, 1.0, m_acamera.mFar); 
  pOGLDev->gcSetRenderTarget(fbo_depthmapcamera);

  gc->gcSetMatrix(gcmtx_proj, m_acamera.mProj.m);
  gc->gcSetMatrix(gcmtx_view, m_acamera.mView.m);
  gc->gcSetParameter(gcpar_depth,		(void*)0x01);
  gc->gcSetParameter(gcpar_color,		(void*)0x00);
  gc->gcSetParameter(gcpar_colormask,	0);
  gc->gcClear(gcflag_depth, 0xffffffff, 1.0, 0);
  gc->gcCull(gc_none);
  m_shader[0]->start();
  m_shader[0]->set("g_mView", m_acamera.mView); 
  m_shader[0]->set("g_mProj", m_acamera.mProj); 
  m_shader[0]->set("g_mTran", m);  

  for(i = 0; i < chunks.size(); i++)
  {
   gc->gcDraw(gcpmt_triangles, gcv_xyz|gcv_col|gcv_nor|gcv_uv0|gcv_uv1, 
	          sizeof(Vertex), 
			  m_vertices,
			  m_pvertices,
			  4, 
			  3 * chunks[i]->count, 
			  &m_pfaces[chunks[i]->offset]
			  );	
  }
  m_shader[0]->stop();
  pOGLDev->gcSetRenderTarget(0);
//*/


///*
//  gc->gcSetRenderTarget(fbo_colormapcamera);
  gc->gcSetTarget(fbo_depthmapcamera);
  gc->gcSetParameter(gcpar_depth,		(void*)0x01);
//  gc->gcSetParameter(gcpar_color,		(void*)0x01);
//  gc->gcSetParameter(gcpar_colormask,	(void*)0xffffffff);
  gc->gcSetParameter(gcpar_colormask,	(void*)0xffffffff);
  gc->gcClear(gcflag_depth | gcflag_color, 0xffffff00, 1.0, 0);

//  m_shader[1]->start();
//  m_shader[1]->set("g_mView", m_acamera.mView); 
//  m_shader[1]->set("g_mProj", m_acamera.mProj); 
//  m_shader[1]->set("g_mTran", m);  
//  m_shader[1]->set("g_txDepth", 0); 
//  m_shader[1]->set("g_txBase",  1); 
//  gc->gcSetRenderTexture(fbo_depthmapcamera, 0, 0x02);

  for(i = 0; i < chunks.size(); i++)
  {
   kgmMaterial* material = 0;
   gc->gcDraw(gcpmt_triangles, gcv_xyz|gcv_col|gcv_nor|gcv_uv0|gcv_uv1, 
	          sizeof(Vertex), 
			  m_vertices,
			  m_pvertices,
			  4, 
			  3 * chunks[i]->count, 
			  &m_pfaces[chunks[i]->offset]
			  );	
  }
  gc->gcSetTexture(0, 0);
//  m_shader[1]->stop();
  gc->gcSetTarget(0);
  gc->gcSetViewport(0, 0, rc.Width(), rc.Height(), 0, m_acamera.mFar);
  gc->gcSetParameter(gcpar_color, (void*)0x01);
  gc->gcSetParameter(gcpar_colormask,	(void*)0xffffffff);
//*/

/*build LightMap in camera space
  m_acamera = m_camera;
  rc = kgmApp::getWindow()->getRect();
  //check lights in camera space and collect them base light always in

//Prepare and clear light map in camera space
  pOGLDev->gcSetViewport(0, 0, m_mapdim, m_mapdim, 0, m_acamera.mFar); 
  pOGLDev->gcSetRenderTexture(&fbo_lightmapcamera);
  gc->gcClear(gcflag_color, 0x00000000, 1.0, 0);
  pOGLDev->gcSetRenderTexture(0);

   //build shadow map for all lights and get to lihtmap
  for(i = 0; i < lights.size(); i++){
	//prepare shadow map
   v = lights[i]->position;
   light = vec4(v.x, v.y, v.z, lights[i]->range); 
   camera.set(PI / 3, 1.0f, 0.1, lights[i]->range, lights[i]->position, vec3(0, 0, -1), vec3(0, 0, 1));
   pOGLDev->gcSetViewport(0, 0, m_mapdim, m_mapdim, 0, m_acamera.mFar); 
   pOGLDev->gcSetRenderTexture(&fbo_depthmaplight);
   
   gc->gcSetParameter(gcpar_depth,		(void*)0x01);
   gc->gcSetParameter(gcpar_color,		(void*)0x00);
   gc->gcSetParameter(gcpar_colormask,	0);
   gc->gcClear(gcflag_depth, 0xffffffff, 1.0, 0);
   gc->gcCull(gc_none);
   gc->gcSetMatrix(gcmtx_proj, camera.mProj.m);
   gc->gcSetMatrix(gcmtx_view, camera.mView.m);
   render(RF_SCENE);
   pOGLDev->gcSetRenderTexture(0);

   gc->gcSetParameter(gcpar_depth,		(void*)0x01);
   gc->gcSetParameter(gcpar_color,		(void*)0x01);
   gc->gcSetParameter(gcpar_colormask,	(void*)0xffffffff);
   gc->gcClear(gcflag_color | gcflag_depth, 0x00000000, 1.0, 0);
    
   //start lightmap 
   pOGLDev->gcSetRenderTexture(&fbo_lightmapcamera);
   gc->gcCull(gccull_back);
   gc->gcSetMatrix(gcmtx_proj, m_acamera.mProj.m);
   gc->gcSetMatrix(gcmtx_view, m_acamera.mView.m);
//	gc->gcBlend(true, gcblend_one, gcblend_one);
   gc->gcSetTexture(0, &fbo_depthmapcamera);
   gc->gcSetTexture(1, &fbo_depthmaplight);
   gc->gcSetShader(m_shLightmap);
   m_shLightmap->set("g_mView", m_acamera.mView); 
   m_shLightmap->set("g_mProj", m_acamera.mProj); 
   m_shLightmap->set("g_mTran", m);  
   m_shLightmap->set("g_tDepth", 0); 
   m_shLightmap->set("g_tShadow", 1); 
   m_shLightmap->set("g_vLight", light); 
   m_shLightmap->set("g_mLight", camera.mVwPj); 
   render(RF_SCENE);
   gc->gcBlend(false, 0, 0);
   gc->gcSetShader(0);
   pOGLDev->gcSetRenderTexture(0);
  }
//*/

///*Final Render
  m_acamera = m_camera;
  gc->gcSetViewport(0, 0, rc.Width(), rc.Height(), 0, m_acamera.mFar);
  gc->gcClear(gcflag_color | gcflag_depth, 0x00000000, 1.0, 0);
  gc->gcCull(gccull_back);
  gc->gcSetMatrix(gcmtx_proj, m_acamera.mProj.m);
  gc->gcSetMatrix(gcmtx_view, m_acamera.mView.m);
//  render(RF_SCENE | RF_ACTORS);
//  render(RF_SCENE);

///* Render Static 
  m_shader[2]->start();
  m_shader[2]->set("g_mView", m_acamera.mView); 
  m_shader[2]->set("g_mProj", m_acamera.mProj); 
  m_shader[2]->set("g_mTran", m);  
  m_shader[2]->set("g_txBase",  0); 
  m_shader[2]->set("g_txBump",  1); 
  m_shader[2]->set("g_txSpec",  2); 

  for(i = 0; i < 16; i++){
   vec4 vL(0, 0, 0, 0);
   char nL[16] = {0};
   if(i < lights.size()){
	kgmLight* l = lights[i];
    vL = vec4(l->position.x, l->position.y, l->position.z, l->intensity);
   }
   sprintf(nL, "g_vLights[%i]", i);
   m_shader[2]->set(nL,  vL); 
  }

  
  for(i = 0; i < chunks.size(); i++)
  {
   kgmMaterial* material = 0;
   gc->gcDraw(gcpmt_triangles, gcv_xyz|gcv_col|gcv_nor|gcv_uv0|gcv_uv1, 
	          sizeof(Vertex), 
			  m_vertices,
			  m_pvertices,
			  4, 
			  3 * chunks[i]->count, 
			  &m_pfaces[chunks[i]->offset]
			  );	
  }
  m_shader[2]->stop();
//*/

///* Render Actors 
  for(i = 0; i < actors.size(); i++)
  {
   draw(actors[i]);
  }
//*/

///* Render Effects 
  for(i = 0; i < effects.size(); i++)
  {
  }
//*/
  gc->gcCull(gc_none);
//*/

///* Testing
  gc->gcSetViewport(0, 0, rc.Width(), rc.Height(), 0, m_acamera.mFar);
  mvw.identity();
  mpr.ortho(0, rc.Width(), rc.Height(), 0, 1, -1);
  gc->gcSetMatrix(gcmtx_proj, mpr.m);
  gc->gcSetMatrix(gcmtx_view, mvw.m);
  gc->gcSetTexture(0, fbo_colormapcamera);
//  kgmExtDrawRect(gc, lRect(0, 700, 500, 300), 0xffffffff, 0);
//  kgmExtDrawRect(gc, lRect(0, 700, 500, 300), 0xffffffff, &m_txOne);
  gc->gcSetTexture(0, 0);
//*/
 lights.clear();
 actors.clear();
 chunks.clear();
 m_lock--;
}

void kgmGameScene::render(uint rf){
 int i = 0;
 uint rndCount = 0;
 
//LOCK

 if(rf & RF_SCENE){
  int i = 0;
  ushort mid = 0;
  for(i = 0; i < (m_chunks.size() - 0); i++)
  {
   mid = m_chunks[i].material;
//   if(mid < m_materials.size())
//	gc->gcSetMaterial(m_materials[mid]);
   if(m_buffer){
    gc->gcDrawVertexBuffer(m_buffer, 
						  gcpmt_triangles, 
						  gcv_xyz|gcv_nor|gcv_col|gcv_uv0|gcv_uv1, 
						  sizeof(Vertex), 
						  m_vertices,
						  4, 
						  3 * m_chunks[i].count,
						  m_chunks[i].offset
						  );
   }else if(m_pvertices && m_pfaces){
	  gc->gcDraw(gcpmt_triangles, gcv_xyz|gcv_col|gcv_nor|gcv_uv0|gcv_uv1, 
		         sizeof(Vertex), 
				 m_vertices,
				 m_pvertices,
				 4, 
				 3 * m_chunks[i].count, 
				 &m_pfaces[m_chunks[i].offset]
				 );	
   }
  }
//  gc->gcSetMaterial(0);
 }
//*/
///*
// Actors
 if(rf & RF_ACTORS){
  for(i = 0; i < m_actors.size(); i++){
   kgmActor* a = m_actors[i];
   kgmSphere3d<float> sp(m_actors[i]->m_position, 10.0f);
   if(!m_actors[i]->enabled() || !m_actors[i]->m_visible)
	  continue;
//   if(m_acamera.isSphereCross(sp.center, sp.radius))
   {
    draw(m_actors[i]);
   }
  }
 }
 //Reset
// gc->gcSetLight(-1, 0);
 gc->gcSetShader(0);
// gc->gcSetMaterial(0);
// gc->gcFog(0);
}

void kgmGameScene::shadows(){
 kgmShader*  shader = m_shShadowmap;
 kgmList<kgmLight*>	active_lights;
 int i = 0, j = 0;

 if(shader == 0){
  m_shaders = true;
  m_enmaterials = true;
  m_render_polygons = true;
  m_render_meshes = true;
  return;
 }

 //Collect Active Lights
 for(i = 0; i < m_lights.size(); i++){
  sphere s(m_lights[i]->position, m_lights[i]->range);
//  if(m_lights[i]->ison && m_camera.isSphereCross(m_lights[i]->position, m_lights[i]->range))
	  active_lights.add(m_lights[i]);
//  else
//	  continue;
 }
 if(active_lights.size() < 1){
  m_shaders = true;
  m_enmaterials = true;
  m_render_polygons = true;
  m_render_meshes = true;
  return;
 }
 //Render Shadow-Cast Geometry In Light Depthmap
 m_render_polygons = false;
 m_render_meshes = false;
 m_shadows = false;
 for(i = 0; i < active_lights.size(); i++){
  vec3 pos = active_lights[i]->position,
	   dir = vec3(0, 0, 0) - pos,//active_lights[i]->direction, 
	   up = vec3(0, 0, 1);
  dir.normalize();
  kgmCamera camera; 
  uint      flags = m_aflags;
//  m_aflags = render_shadows;
  camera.set(m_lfov, 1.0, 1.0, 1000.0, pos, dir, up);
//  if(active_lights[i]->shadowmap)
//   render(&active_lights[i]->shadowmap);
  m_aflags = flags;
 }
 m_shadows = true;
/*
 gc->gcSetMatrix(gcmtx_proj, m_camera.mProj.m);
 gc->gcSetMatrix(gcmtx_view, m_camera.mView.m);
 gc->gcAlpha(true, gccmp_less, 0.6);
 gc->gcBlend(true, gcblend_srcalpha, gcblend_srcialpha);
 //Start Shadowmap Shader
 if(shader)   shader->start();
 //Render Shadow-Reseive Geometry In Viewspace
 //comparing with Lights Depthmap
 for(i = 0; i < m_polygons.size(); i++){
  kgmPolygon* poly = m_polygons[i];
  sphere sp(poly->m_box);
//  if(m_camera.isSphereCross(sp.center, sp.radius) == false)
//	  continue;
  for(j = 0; j < active_lights.size(); j++){
   kgmLight* light = active_lights[j];
   vec3 pos = light->position,
	    dir = vec3(0, 0, 0) - pos, //light->direction, 
	    up = vec3(0, 0, 1);
   dir.normalize();
   kgmCamera camera; 
   camera.set(m_lfov, 1.0, 1.0, 1000.0, pos, dir, up);
//   if(camera.isSphereCross(sp.center, sp.radius) == false)
//	   continue;

   mtx4 m, mlight, mlview, mlproj;
//   mlproj.identity();
//   mlproj.perspective(m_lfov, 1.0, 1.0, 1000);
//   mlview.identity();
//   mlview.lookat(pos, dir, up);
//   mlight = mlview * mlproj;
//   mlight = mlproj * mlview;
   mlight = camera.mVwPj;
   m.identity();
   vec4 vlight; 
		vlight.x = light->position.x;
		vlight.y = light->position.y;
		vlight.z = light->position.z;
		vlight.w = light->range;
   gc->gcSetTexture(0, &light->shadowmap);
   shader->set("txDepth",		0);
   shader->set("light",			vlight);
   shader->set("eye_position",	m_camera.mPos);
   shader->set("eye_direction", m_camera.mDir);
   shader->set("g_mLight",		mlight);
   shader->set("g_mView",		m_camera.mView);
   shader->set("g_mProj",		m_camera.mProj);
   shader->set("g_mTran",		m);
   gc->gcDraw(gcpmt_trianglefan, gcv_xyz | gcv_nor | gcv_col | gcv_uv0 | gcv_uv1, 
              sizeof(kgmPolygon::Vertex),  poly->verts.count(), poly->verts, 0, 0, 0);
  }
 }
 if(shader)   shader->stop();
 gc->gcAlpha(false, 0, 0);
 gc->gcBlend(false, 0, 0);
//*/
 m_shaders = true;
 m_enmaterials = true;
 m_render_polygons = true;
 m_render_meshes = true;
 active_lights.clear();
}

void kgmGameScene::set(kgmIGraphics* g){
 gc = g;
}


//PAINT SECTION
void kgmGameScene::draw(kgmActor* a){
 bool is = false; 
 if(a->m_mesh){
  kgmMesh* mesh  = a->m_mesh;
  kgmMaterial* material = a->m_material;
  mtx4 mTr = a->m_transform * m_acamera.mView;
  gc->gcSetMatrix(gcmtx_view, mTr.m);
//  if(material)
//	  gc->gcSetMaterial(material);
  if(mesh)
	  gc->gcDraw(gcpmt_triangles, mesh->fvf(), mesh->vsize(), mesh->vcount(), mesh->vertices(), 
				 2, 3 * mesh->fcount(), mesh->faces());
//  gc->gcSetMaterial(0);
  gc->gcSetMatrix(gcmtx_view, m_acamera.mView.m);
 }
}

void kgmGameScene::draw(kgmSprite* sprite){

}



// Retreive nearest light
kgmLight* kgmGameScene::lightshadow(vec3& pos){
 kgmLight*  light = &m_light;
 float		dist = 0.0;
 float		value = 0.0;

 dist = pos.distance(light->position);
 if(dist < 1.0)
	 dist = 1.0;
// value = light->intensity / dist;
 value = light->range / dist;

 if(m_lights.size() < 1)
	 return light;

 light = m_lights[0];
 dist = pos.distance(light->position);
 for(int i = 1; i < m_lights.size(); i++){
  float ndist = 0.0; 
  float nvalue = 0.0;
  ndist = pos.distance(m_lights[i]->position);
  if(ndist < 1.0f)
	  ndist = 1.0f;
  value = m_lights[i]->range / ndist;
  if(nvalue > value){
   light = m_lights[i];
   value = nvalue;
  }
 }
 return light;
}

